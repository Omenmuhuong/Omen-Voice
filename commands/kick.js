const {
  SlashCommandBuilder,
  PermissionFlagsBits,
  ActionRowBuilder,
  UserSelectMenuBuilder,
  ComponentType,
} = require("discord.js");
const fs = require("fs");
const path = require("path");

const tempPath = path.join(__dirname, "../data/tempChannels.json");

// ==== üì• ƒê·ªçc danh s√°ch k√™nh t·∫°m ====
function loadTempChannels() {
  if (!fs.existsSync(tempPath)) return [];
  try {
    return JSON.parse(fs.readFileSync(tempPath, "utf8"));
  } catch (err) {
    console.error("‚ùå L·ªói khi ƒë·ªçc tempChannels.json:", err);
    return [];
  }
}

module.exports = {
  data: new SlashCommandBuilder()
    .setName("kick")
    .setDescription("‚ùå ƒê√° m·ªôt ng∆∞·ªùi kh·ªèi voice hi·ªán t·∫°i"),

  async execute(interaction) {
    const member = interaction.member;
    const voiceChannel = member.voice.channel;

    if (!voiceChannel) {
      return interaction.reply({
        content: "‚ùå B·∫°n ƒëang kh√¥ng trong m·ªôt voice chat!",
        ephemeral: true,
      });
    }

    // üîê Gi·ªõi h·∫°n l·ªánh ch·ªâ d√πng trong k√™nh t·∫°m
    const tempChannels = loadTempChannels();
    if (!tempChannels.includes(voiceChannel.id)) {
      return interaction.reply({
        content: "‚ùå L·ªánh n√†y ch·ªâ d√πng trong k√™nh voice t·∫°m!",
        ephemeral: true,
      });
    }

    const members = voiceChannel.members.filter(
      (m) => !m.user.bot && m.id !== member.id,
    );

    if (members.size === 0) {
      return interaction.reply({
        content: "‚ùå Kh√¥ng c√≥ ai ƒë·ªÉ kick trong voice n√†y (ngo√†i b·∫°n v√† bot)!",
        ephemeral: true,
      });
    }

    const select = new UserSelectMenuBuilder()
      .setCustomId("kick_user_select")
      .setPlaceholder("Ch·ªçn ng∆∞·ªùi ƒë·ªÉ kick kh·ªèi voice")
      .setMinValues(1)
      .setMaxValues(1);

    const row = new ActionRowBuilder().addComponents(select);

    await interaction.reply({
      content: "üîΩ Ch·ªçn ng∆∞·ªùi b·∫°n mu·ªën **kick** kh·ªèi voice:",
      components: [row],
      ephemeral: true,
    });

    const collector = interaction.channel.createMessageComponentCollector({
      componentType: ComponentType.UserSelect,
      time: 15_000,
      max: 1,
      filter: (i) => i.user.id === interaction.user.id,
    });

    collector.on("collect", async (selectInteraction) => {
      const targetId = selectInteraction.values[0];
      const targetMember = voiceChannel.members.get(targetId);

      if (!targetMember) {
        return selectInteraction.update({
          content: "‚ùå Ng∆∞·ªùi n√†y kh√¥ng c√≤n trong voice!",
          components: [],
        });
      }

      const owner = voiceChannel.members.find((m) =>
        voiceChannel.permissionsFor(m).has(PermissionFlagsBits.ManageChannels),
      );

      if (owner?.id === targetId) {
        return selectInteraction.update({
          content: "‚ùå B·∫°n kh√¥ng th·ªÉ kick ch·ªß ph√≤ng!",
          components: [],
        });
      }

      await targetMember.voice.disconnect();

      await selectInteraction.update({
        content: `‚ùå ƒê√£ kick <@${targetId}> kh·ªèi voice chat.`,
        components: [],
      });
    });

    collector.on("end", (collected) => {
      if (collected.size === 0) {
        interaction.editReply({
          content: "‚è±Ô∏è H·∫øt th·ªùi gian ch·ªçn ng∆∞·ªùi ƒë·ªÉ kick.",
          components: [],
        });
      }
    });
  },
};
